
Quaternion QuaternionLookAt(const Dali::Vector3& from, const Dali::Vector3& to, const Dali::Vector3& up = Dali::Vector3::YAXIS)
{
  auto forward = (to - from);
  if (forward.LengthSquared() < 1e-6f)
  {
    DALI_LOG_RELEASE_INFO("LookAt: from and to are too close; returning identity quaternion\n");
    return Quaternion();
  }

  forward.Normalize();
  auto defaultForward = Vector3::ZAXIS;

  if ((forward + defaultForward).LengthSquared() < 1e-6f)
  {
    DALI_LOG_RELEASE_INFO("LookAt: 180-degree rotation case detected\n");
    return Quaternion(Radian(Math::PI), up);
  }

  auto rotationAxis = defaultForward.Cross(forward);
  rotationAxis.Normalize();

  auto angle = std::acos(defaultForward.Dot(forward));

  DALI_LOG_RELEASE_INFO("LookAt: angle: %.3f, axis: (%.3f, %.3f, %.3f)\n", angle, rotationAxis.x, rotationAxis.y, rotationAxis.z);

  return Quaternion(Radian(angle), rotationAxis);
}


void AdjustHighlightOrientation(Dali::Actor& highlight)
{
  auto modelFound = false;
  auto totalInverseRotation = Quaternion::IDENTITY;
  auto current = highlight.GetParent();

  Scene3D::SceneView sceneView;

  while (current)
  {
    sceneView = Scene3D::SceneView::DownCast(current);
    if (sceneView)
    {
      DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: SceneView found\n");
      break;
    }

    if (Scene3D::Model::DownCast(current)) {
      modelFound = true;
    }

    auto orientationValue = current.GetProperty(Actor::Property::ORIENTATION);
    Quaternion parentRotation;
    if (orientationValue.Get(parentRotation))
    {
      parentRotation.Invert();
      totalInverseRotation *= parentRotation;

      DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: Inverted parent rotation applied\n");
    }
    else
    {
      DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: Failed to get parent rotation\n");
    }

    current = current.GetParent();
  }

  if (!sceneView)
  {
    highlight.SetProperty(Actor::Property::ANCHOR_POINT, AnchorPoint::TOP_LEFT);
    highlight.SetProperty(Actor::Property::PARENT_ORIGIN, ParentOrigin::TOP_LEFT);
    highlight.SetProperty(Actor::Property::ORIENTATION, Quaternion());

    highlight.SetProperty(Actor::Property::POSITION_Z, 1.0f);
    highlight.SetProperty(Actor::Property::POSITION, Vector2(0.0f, 0.0f));
    DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: SceneView not found, aborting\n");
    return;
  }

  if (!modelFound)
  {
    DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation:No Model found\n");
    return;
  }

  auto camera = sceneView.GetSelectedCamera();
  if (!camera)
  {
    DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: Selected camera is null\n");
    return;
  }

  Vector3 camPos;
  if (!camera.GetProperty(Actor::Property::POSITION).Get(camPos))
  {
    DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: Failed to get camera position\n");
    return;
  }

  Vector3 highlightPos;
  if (!highlight.GetProperty(Actor::Property::POSITION).Get(highlightPos))
  {
    DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: Failed to get highlight position\n");
    return;
  }

  DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: highlightPos (%.2f, %.2f, %.2f), camPos (%.2f, %.2f, %.2f)\n",
                        highlightPos.x, highlightPos.y, highlightPos.z,
                        camPos.x, camPos.y, camPos.z);

  auto lookAtRotation = QuaternionLookAt(highlightPos, camPos);
  auto finalRotation = totalInverseRotation * lookAtRotation;


  highlight.SetProperty(Actor::Property::ANCHOR_POINT, AnchorPoint::CENTER);
  highlight.SetProperty(Actor::Property::PARENT_ORIGIN, ParentOrigin::CENTER);
  highlight.SetProperty(Actor::Property::ORIENTATION, finalRotation);


  // const float offset = -10.0f;
  
  // Vector3 cameraOri;
  // if (camera.GetProperty(Actor::Property::ORIENTATION).Get(cameraOri))
  // {
  //   Vector3 cameraForward = cameraOri * Vector3::ZAXIS;
  //   cameraForward.Normalize();
  //   auto newPosition = highlightPos + cameraForward * offset;    
  //   highlight.SetProperty(Actor::Property::POSITION, newPosition);
  // }

  DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: Orientation applied successfully\n");
}

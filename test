Quaternion QuaternionLookAtHorizontally(const Dali::Vector3& from, const Dali::Vector3& to)
{
  using namespace Dali;

  Vector3 direction = to - from;
  if (direction.LengthSquared() < 1e-6f)
  {
    DALI_LOG_RELEASE_INFO("LookAtHorizontally: from and to are too close; identity\n");
    return Quaternion();
  }

  // 카메라를 향하는 방향 유지 (정확히 보게 함)
  direction.Normalize();

  // y축 기준 수평 방향으로 투영 (XZ 평면상 방향)
  Vector3 horizontalForward = direction;
  horizontalForward.y = 0.0f;

  if (horizontalForward.LengthSquared() < 1e-6f)
  {
    // 카메라가 완전히 위나 아래에 있는 경우 → 수평 회전 무의미
    DALI_LOG_RELEASE_INFO("LookAtHorizontally: vertical camera angle; skipping rotation\n");
    return Quaternion();
  }

  horizontalForward.Normalize();

  // defaultForward는 오브젝트가 원래 바라보는 기준방향
  Vector3 defaultForward = Vector3::ZAXIS;

  // 쿼터니언 생성용 회전 축/각도
  Vector3 rotationAxis = defaultForward.Cross(horizontalForward);
  rotationAxis.Normalize();

  float angle = std::acos(defaultForward.Dot(horizontalForward));

  DALI_LOG_RELEASE_INFO("LookAtHorizontally: angle %.2f, axis (%.2f, %.2f, %.2f)\n",
                        angle, rotationAxis.x, rotationAxis.y, rotationAxis.z);

  return Quaternion(Radian(angle), rotationAxis);
}



Quaternion QuaternionLookAtHorizontally(const Dali::Vector3& from, const Dali::Vector3& to)
{
  using namespace Dali;

  auto forward = (to - from);
  if (forward.LengthSquared() < 1e-6f)
  {
    DALI_LOG_RELEASE_INFO("LookAtHorizontally: from and to are too close; returning identity quaternion\n");
    return Quaternion();
  }

  // 월드 수직(Y축)을 유지한 채 방향 벡터만 사용
  forward.Normalize();

  // 투영: forward 벡터를 월드 수평면 (XZ 평면)에 투영하여 tilt 제거
  forward.y = 0.0f;
  if (forward.LengthSquared() < 1e-6f)
  {
    DALI_LOG_RELEASE_INFO("LookAtHorizontally: direction is vertical; using identity\n");
    return Quaternion();
  }

  forward.Normalize();
  auto defaultForward = Vector3::ZAXIS;

  // 180도 회전 예외 처리
  if ((forward + defaultForward).LengthSquared() < 1e-6f)
  {
    DALI_LOG_RELEASE_INFO("LookAtHorizontally: 180-degree rotation case detected\n");
    return Quaternion(Radian(Math::PI), Vector3::YAXIS);
  }

  auto rotationAxis = defaultForward.Cross(forward);
  rotationAxis.Normalize();

  auto angle = std::acos(defaultForward.Dot(forward));

  DALI_LOG_RELEASE_INFO("LookAtHorizontally: angle: %.3f, axis: (%.3f, %.3f, %.3f)\n",
                        angle, rotationAxis.x, rotationAxis.y, rotationAxis.z);

  return Quaternion(Radian(angle), rotationAxis);
}

Quaternion QuaternionLookAtHorizontally(const Dali::Vector3& from, const Dali::Vector3& to)
{
  using namespace Dali;

  auto forward = (to - from);
  if (forward.LengthSquared() < 1e-6f)
  {
    DALI_LOG_RELEASE_INFO("LookAtHorizontally: from and to are too close; returning identity quaternion\n");
    return Quaternion();
  }

  // 월드 수직(Y축)을 유지한 채 방향 벡터만 사용
  forward.Normalize();

  // 투영: forward 벡터를 월드 수평면 (XZ 평면)에 투영하여 tilt 제거
  forward.y = 0.0f;
  if (forward.LengthSquared() < 1e-6f)
  {
    DALI_LOG_RELEASE_INFO("LookAtHorizontally: direction is vertical; using identity\n");
    return Quaternion();
  }

  forward.Normalize();
  auto defaultForward = Vector3::ZAXIS;

  // 180도 회전 예외 처리
  if ((forward + defaultForward).LengthSquared

Quaternion LookAtHorizontally(const Vector3& from, const Vector3& to)
{
  using namespace Dali;

  Vector3 forward = (to - from).Normalize();
  Vector3 up = Vector3::YAXIS; // 항상 월드 수직축 고정

  // 카메라가 수직 정렬 상태에서 정확히 위/아래를 보면 Cross가 0됨 → 보정 필요
  if (fabsf(forward.Dot(up)) > 0.99f)
  {
    up = Vector3::ZAXIS; // 보조 수직축 사용
  }

  Vector3 right = up.Cross(forward).Normalize();
  Vector3 correctedUp = forward.Cross(right).Normalize();

  Matrix3 rotationMatrix(
    right.x,     right.y,     right.z,
    correctedUp.x, correctedUp.y, correctedUp.z,
    forward.x,   forward.y,   forward.z
  );

  return Quaternion(rotationMatrix);
}
Quaternion QuaternionLookAt(const Dali::Vector3& from, const Dali::Vector3& to, const Dali::Vector3& up = Dali::Vector3::YAXIS)
{
  auto forward = (to - from);
  if (forward.LengthSquared() < 1e-6f)
  {
    DALI_LOG_RELEASE_INFO("LookAt: from and to are too close; returning identity quaternion\n");
    return Quaternion();
  }

  forward.Normalize();
  auto defaultForward = Vector3::ZAXIS;

  if ((forward + defaultForward).LengthSquared() < 1e-6f)
  {
    DALI_LOG_RELEASE_INFO("LookAt: 180-degree rotation case detected\n");
    return Quaternion(Radian(Math::PI), up);
  }

  auto rotationAxis = defaultForward.Cross(forward);
  rotationAxis.Normalize();

  auto angle = std::acos(defaultForward.Dot(forward));

  DALI_LOG_RELEASE_INFO("LookAt: angle: %.3f, axis: (%.3f, %.3f, %.3f)\n", angle, rotationAxis.x, rotationAxis.y, rotationAxis.z);

  return Quaternion(Radian(angle), rotationAxis);
}

void AdjustHighlightOrientation(Dali::Actor& highlight)
{
  auto modelFound = false;
  auto totalInverseRotation = Quaternion::IDENTITY;
  auto current = highlight.GetParent();

  Scene3D::SceneView sceneView;

  while (current)
  {
    sceneView = Scene3D::SceneView::DownCast(current);
    if (sceneView)
    {
      DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: SceneView found\n");
      break;
    }

    if (Scene3D::Model::DownCast(current)) {
      modelFound = true;
    }

    auto orientationValue = current.GetProperty(Actor::Property::ORIENTATION);
    Quaternion parentRotation;
    if (orientationValue.Get(parentRotation))
    {
      parentRotation.Invert();
      totalInverseRotation *= parentRotation;

      DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: Inverted parent rotation applied\n");
    }
    else
    {
      DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: Failed to get parent rotation\n");
    }

    current = current.GetParent();
  }

  if (!sceneView)
  {
    highlight.SetProperty(Actor::Property::ANCHOR_POINT, AnchorPoint::TOP_LEFT);
    highlight.SetProperty(Actor::Property::PARENT_ORIGIN, ParentOrigin::TOP_LEFT);
    highlight.SetProperty(Actor::Property::ORIENTATION, Quaternion());

    highlight.SetProperty(Actor::Property::POSITION_Z, 1.0f);
    highlight.SetProperty(Actor::Property::POSITION, Vector2(0.0f, 0.0f));
    DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: SceneView not found, aborting\n");
    return;
  }

  if (!modelFound)
  {
    DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation:No Model found\n");
    return;
  }

  auto camera = sceneView.GetSelectedCamera();
  if (!camera)
  {
    DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: Selected camera is null\n");
    return;
  }

  Vector3 camPos;
  if (!camera.GetProperty(Actor::Property::POSITION).Get(camPos))
  {
    DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: Failed to get camera position\n");
    return;
  }

  Vector3 highlightPos;
  if (!highlight.GetProperty(Actor::Property::POSITION).Get(highlightPos))
  {
    DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: Failed to get highlight position\n");
    return;
  }

  DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: highlightPos (%.2f, %.2f, %.2f), camPos (%.2f, %.2f, %.2f)\n",
                        highlightPos.x, highlightPos.y, highlightPos.z,
                        camPos.x, camPos.y, camPos.z);

  auto lookAtRotation = QuaternionLookAt(highlightPos, camPos);
  auto finalRotation = totalInverseRotation * lookAtRotation;


  highlight.SetProperty(Actor::Property::ANCHOR_POINT, AnchorPoint::CENTER);
  highlight.SetProperty(Actor::Property::PARENT_ORIGIN, ParentOrigin::CENTER);
  highlight.SetProperty(Actor::Property::ORIENTATION, finalRotation);


  const float offset = -1.0f;
  highlight.SetProperty(Actor::Property::POSITION, Vector3(0.0f, offset, 0.0f));
  DALI_LOG_RELEASE_INFO("AdjustHighlightOrientation: Orientation applied successfully\n");
}
